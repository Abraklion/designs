# Сортировка пузырьком `Bubble Sort`

Сортировка пузырьком, иногда называемая сортировкой погружением, представляет собой простой алгоритм сортировки, который многократно проходит через список для сортировки, сравнивает каждую пару соседних элементов и меняет их местами, если они расположены в неправильном порядке (по возрастанию или по убыванию). Проход по списку повторяется до тех пор, пока перестановки не понадобятся, что указывает на то, что список отсортирован.

![Сортировка пузырьком](./img.gif)

## Сложность

|       Наименование       | Лучший случай | Средний случай | Худший случай | Память | Устойчивость | Комментарии |
|:------------------------:|:-------------:|:--------------:|:-------------:|:------:|:------------:|:-----------:|
| **Сортировка пузырьком** |      `n`      |     `n^2`      |     `n^2`     |  `1`   |     `да`     |             |


## Примеры

- [Пример 1 - реализация сортировки пузырьком](#Пример-1)

---

### Пример 1

### `Шаг 1`

_В этой демонстрации реализуем на практике сортировку пузырьком_

````js
function bubbleSort(array) {
  return [];
}

bubbleSort([5, 3, 2, 1]) // => [1, 2, 3, 5]
bubbleSort([1, 2, 3])    // => [1, 2, 3]
````

### `Шаг 2`

_Сначала напишем простую версию, без разделения на сортированный и несортированный подмассивы, а потом оптимизируем её. Для этого нам нужно проитерироваться по всему массиву n раз._

````js
function bubbleSort(array) {
  
  // проходим весь массив столько раз, сколько в нём элементов - 1, потому что, как мы выяснили в статье,
  // последняя итерация "добьет" сразу два последних элемента
  for (let i = 0; i < array.length - 1; i++) {
    
    // в рамках каждого прохода нам тоже нужно просматривать на один элемент меньше,
    // ведь для последнего элемента мы не найдем следующий, с которым будем его сравнивать
    for (let j = 0; j < array.length - 1; j++) {
      // ...
    }
    
  }

  return array;
}

bubbleSort([5, 3, 2, 1]) // => [1, 2, 3, 5]
bubbleSort([1, 2, 3])    // => [1, 2, 3]
````

### `Шаг 3`

_Осталось лишь дописать попарное сравнение элементов и их смену, и наша сортировка готова!_

````js
function bubbleSort(array) {
  
  // проходим весь массив столько раз, сколько в нём элементов - 1, потому что, как мы выяснили в статье,
  // последняя итерация "добьет" сразу два последних элемента
  for (let i = 0; i < array.length - 1; i++) {
    
    // в рамках каждого прохода нам тоже нужно просматривать на один элемент меньше,
    // ведь для последнего элемента мы не найдем следующий, с которым будем его сравнивать
    for (let j = 0; j < array.length - 1; j++) {
      
      // если элемент слева больше элемента справа...
      if (array[j] > array[j + 1]) {
        
        /// ... меняем их местами
        [array[j], array[j + 1]] = [array[j + 1], array[j]];
      }
      
    }
    
  }

  return array;
}

bubbleSort([5, 3, 2, 1]) // => [1, 2, 3, 5]
bubbleSort([1, 2, 3])    // => [1, 2, 3]
````

### `Шаг 4`

_А теперь можем дописать небольшую оптимизацию. Мы точно знаем, что в каждый проход самое большое число «всплывает» в конец массива, поэтому и проходить по ним каждый раз не нужно. Каждый проход будем игнорировать уже отсортированную часть массива. Важно понимать, что хотя мы и отсекли часть ненужных проходов, общая сложность алгоритма всё ещё квадратичная! Можете убедиться в этом сами, например, посчитав количество операций для списка из трёх и четырёх элементов._

````js
function bubbleSort(array) {
  
  // проходим весь массив столько раз, сколько в нём элементов - 1, потому что, как мы выяснили в статье,
  // последняя итерация "добьет" сразу два последних элемента
  for (let i = 0; i < array.length - 1; i++) {
    
    // в рамках каждого прохода нам тоже нужно просматривать на один элемент меньше,
    // ведь для последнего элемента мы не найдем следующий, с которым будем его сравнивать
    // а ещё каждую итерацию будем смотреть на один элемент поменьше, ведь справа будет уже сортированная его часть
    for (let j = 0; j < array.length - 1 - i; j++) {
      
      // если элемент слева больше элемента справа...
      if (array[j] > array[j + 1]) {
        
        /// ... меняем их местами
        [array[j], array[j + 1]] = [array[j + 1], array[j]];
        
      }
      
    }
    
  }

  return array;
}

bubbleSort([5, 3, 2, 1]) // => [1, 2, 3, 5]
bubbleSort([1, 2, 3])    // => [1, 2, 3]
````










