# Сортировка вставкой `Insertion Sort`

Сортировка вставками — это простой алгоритм сортировки, который строит окончательный отсортированный массив (или список) по одному элементу за раз. Он гораздо менее эффективен для больших списков, чем более продвинутые алгоритмы, такие как быстрая сортировка, пирамидальная сортировка или сортировка слиянием.

![Сортировка вставкой](./img.gif) 

![Сортировка вставкой](./img2.gif)

## Сложность

|      Наименование       | Лучший случай | Средний случай | Худший случай | Память | Устойчивость | Комментарии |
|:-----------------------:|:-------------:|:--------------:|:-------------:|:------:|:------------:|:-----------:|
| **Сортировка вставкой** |      `n`      |     `n^2`      |     `n^2`     |  `1`   |     `да`     |             |


## Примеры

- [Пример 1 - реализация сортировки вставкой](#Пример-1)
- [Пример 2 - добавление нового элемента и соритовынный массив](#Пример-2)

---

### Пример 1

### `Шаг 1`

_В этой демонстрации реализуем на практике сортировки вставкой_

````js
function insetionSort(array) {
  return [];
}

insetionSort([5, 3, 2, 1]) // => [1, 2, 3, 5]
insetionSort([1, 2, 3])    // => [1, 2, 3]
````

### `Шаг 2`

_Проходимся по исходный "**исходный последовательность**" для того что бы начать создавать "**готовую последовательность**"_

````js
function insetionSort(array) {

  // проходимся по всему массиву который надо отсортировать, минус последний элемент
  for (let i = 0; i < array.length - 1; i++) {
    
    // следующий индекс в итерации(исходный последовательность)
    let j = i + 1
    
    // если следующий элемент в итерации(исх. послед-ти), меньше чем текущий элемент в итерации(готовый последовательности)
    // запускаем цикл что бы найти место для этого элемента в готовый последовательность
    while (j !== 0 && array[j] < array[j - 1]) {
      
    }
    
  }
  
  return [];
}

insetionSort([5, 3, 2, 1]) // => [1, 2, 3, 5]
insetionSort([1, 2, 3])    // => [1, 2, 3]
````

### `Шаг 3`

_Если условия while сробатывает находим элементу место в **готовый последовательности**_

````js
function insetionSort(array) {

  // проходимся по всему массиву который надо отсортировать, минус последний элемент
  for (let i = 0; i < array.length - 1; i++) {

    // следующий индекс в итерации(исходный последовательность)
    let j = i + 1

    // если следующий элемент в итерации(исх. послед-ти), меньше чем текущий элемент в итерации(готовый последовательности)
    // запускаем цикл что бы найти место для этого элемента в готовый последовательность
    while (j !== 0 && array[j] < array[j - 1]) {

      // ... меняем их местами
      [array[j], array[j - 1]] = [array[j - 1], array[j]];
      
      // уменьшаем индекс
      j--
    }

  }

  return array;
}

insetionSort([5, 3, 2, 1]) // => [1, 2, 3, 5]
insetionSort([1, 2, 3])    // => [1, 2, 3]
````

### Пример 2

### `Шаг 1`

_Некоторые веб-приложения выводят уже сортированный набор данных пользователю, а затем, дозапрашивая данные с сервера, добавляют их в этот набор и сортируют заново. Но ведь гораздо проще и эффективнее, имея небольшой массив и небольшой набор добавляемых данных, просто поддерживать наш массив отсортированным! Самый простой из примеров, где это может использоваться — инвестиционное приложение, которое сразу же показывает сегодняшние цены на популярные акции, а затем подгружает остальные. Как уже было сказано в прошлой статье, сортировка вставкой — одна из немногих, которая может с небольшой сложностью поддержать любой наш список сортированным. Давайте напишем функцию sortPush, с помощью которой можно будет добавить новый элемент в уже отсортированный массив из цен акций._

````js
function sortPush(array, element) {
  return array;
}

// Список из заранее загруженных данных
const data = [
  {
    ticker: 'WISH',
    price: 5.14
  },
  {
    ticker: 'SPCE',
    price: 20.10
  },
  {
    ticker: 'AAPL',
    price: 151.86
  },
  {
    ticker: 'QCOM',
    price: 155.98,
  },
  {
    ticker: 'ABNB',
    price: 178.06,
  }
];

const loaded = {
  ticker: 'BABA',
  price: 166.99
}

sortPush(data, loaded); // Добавит новый элемент предпоследним в наш список
````

### `Шаг 2`

_Нам также нужно сначала найти место, где должен встать новый элемент, найдя первый элемент больше него._

````js
function sortPush(array, element) {
  // Сначала предположим, что элемент пойдет прямо в начало массива
  let pointOfInsertion = 0;

  // Пока не встретим элемент больше вставляемого или конец массива...
  while (pointOfInsertion < array.length && element.price > array[pointOfInsertion].price) {
    // ... двигаем указатель на место вставки
    pointOfInsertion++;
  }

  return array;
}

// Список из заранее загруженных данных
const data = [
  {
    ticker: 'WISH',
    price: 5.14
  },
  
  //...
  
];

const loaded = {
  ticker: 'BABA',
  price: 166.99
}

sortPush(data, loaded); // Добавит новый элемент предпоследним в наш список
````

### `Шаг 3`

_А вместо обновления связей, как мы сделали бы в связном списке, разделим наш массив на части до и после вставляемого элемента и положим его между ними._

````js
function sortPush(array, element) {
  // Сначала предположим, что элемент пойдет прямо в начало массива
  let pointOfInsertion = 0;

  // Пока не встретим элемент больше вставляемого или конец массива...
  while (pointOfInsertion < array.length && element.price > array[pointOfInsertion].price) {
    // ... двигаем указатель на место вставки
    pointOfInsertion++;
  }

  return pointOfInsertion === 0
    ? [element, ...array]
    : [...array.slice(0, pointOfInsertion), element, ...array.slice(pointOfInsertion)];
}

// Список из заранее загруженных данных
const data = [
  {
    ticker: 'WISH',
    price: 5.14
  },
  
  //...
  
];

const loaded = {
  ticker: 'BABA',
  price: 166.99
}

sortPush(data, loaded); // Добавит новый элемент предпоследним в наш список
````








